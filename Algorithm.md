### 最长回文

* 暴力判断 O(n^3)
* 后缀树 O(n)
    1. 翻转字符串（后续可以查找后缀的最低公共祖先）
    2. 构建两个字符串的后缀树，不同字符串加不同后缀标识
    3. 查找最低公共祖先（按照i，n-i+1对应查找）
* 动态规划 O(n^2)
    1. 父回文的判断条件由子回文判断+两头值判断决定
* 中间扩散两边 O(n^2)
* 马拉车算法 O(n)
    1. 填充特殊分割至字符串奇数个
    2. 特定区域条件判断
    
### 模式匹配(S字符串中查找匹配T的位置)

* 暴力回溯匹配 O(mn)(大多数情况趋近O(m+n))
* KMP O(m+n)(减少i回溯，预先计算next函数，在匹配失效时模式串后退k个字符进行匹配)

### hash冲突的解决办法
* 开放地址法（再散列法）
    探查次数 <= 1 / (1 - α)
* 再哈希法
* 链地址法（拉链法O(1+α)） hashmap采用
    除法哈希(除数选质数避免求余得出相同低位值)
    乘法哈希
* 建立公共溢出区

### LRU

    LinkedHashMap(HashMap+双向链表)
    
### Arrays.sort原理
* 首先检查数组长度，如果比阀值（286）小，直接使用双轴快排
    > 类似三向切分的快速排序，分三段结果段，一段未知段，两个pivot
* 否则先检查数组中数据的连续性，标记连续升序，反转连续降序，如果连续性好，使用 TimSort 算法（可以很好的利用数列中的原始
顺序）
    > TimSort是归并排序的优化，先按连续区分run，再根据Galloping(合并时机和方法)合并，最优复杂度O(n)
* 否则使用双轴快排 + 成对插入排序